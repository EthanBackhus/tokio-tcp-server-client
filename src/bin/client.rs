use mini_redis::client;
use bytes::Bytes;
use tokio::sync::mpsc;
use tokio::sync::oneshot;

// mpsc = multi-producer, single consumer channel

#[tokio::main]
async fn main() {

    // create a new channel, with the capacity of at most 32
    let (tx, mut rx) = mpsc::channel(32);

    // The `move` keyword is used to **move** ownership of `rx` into the task.
    let manager = tokio::spawn(async move {
       // Establish a connection to the server
       let mut client = client::connect("127.0.0.1:6379").await.unwrap();

       // Start receiving messages
       while let Some(cmd) = rx.recv().await {
           use Command::*;

           match cmd {
               Get { key, resp} => {
                   let res = client.get(&key).await;
                   // ignore errors
                   let _ = resp.send(res);
               }
               Set { key, val, resp} => {
                   let res = client.set(&key, val).await;
                   //ignore errors
                   let _ = resp.send(res);
               }
           }
       }
    });

    // the 'sender' handles are moved into the tasks. As there are two
    // tasks, we need 2 senders
    let tx2 = tx.clone();

    // spawn 2 tasks, one gets a key, one sends a key
    let t1 = tokio::spawn(async move {
        let (resp_tx, resp_rx) = oneshot::channel();
        let cmd = Command::Get { 
            key: "test".to_string(),
            resp: resp_tx,
        };

        // send the GET request
        tx.send(cmd).await.unwrap();

        // await the response
        let res = resp_rx.await;
        println!("GOT = {:?}", res);
    });

    let t2 = tokio::spawn(async move {
        let (resp_tx, resp_rx) = oneshot::channel();
        let cmd = Command::Set { 
            key: "test".to_string(), 
            val: "ing".into(),
            resp: resp_tx
        };

        // send the SET request
        tx2.send(cmd).await.unwrap();

        // await the response
        let res = resp_rx.await;
        println!("GOT = {:?}", res);
    });

    t1.await.unwrap();
    t2.await.unwrap();
    manager.await.unwrap();
}

// multiple different commands are multi-plexed over a single channel
#[derive(Debug)]
enum Command {
    Get {
        key: String,
        resp: Responder<Option<Bytes>>,
    },
    Set {
        key: String,
        val: Bytes,
        resp: Responder<()>,
    },
}

// provided by the requester and used by the manager task to 
// send the command response back to the requester
type Responder<T> = oneshot::Sender<mini_redis::Result<T>>;